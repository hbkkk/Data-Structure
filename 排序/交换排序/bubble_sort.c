/****************************************冒泡排序****************************************/
//
//方法一:遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小； 如果前者比后者大，则交换它们的位置。这样，一次遍历后，最大的元素就在数列的末尾！
//	采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！   有n个数的数列进行n-1次
//
//方法二(效率更高):
//	方法一中，就算某次遍历已经是排序好了的数列，还是会继续进行下去，所以这里添加一个标记，如果一趟遍历中发生了交换，标记置为true，否则为false。
//	如果某一趟遍历中没发生交换，就说明排序已经完成！
//
//	时间复杂度：O(N^2)     假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。
//			
//     【稳定性】：是稳定的算法。	算法稳定性定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) ((a)^=(b), (b)^=(a), (a)^=(b))   //用异或来实现两数交换。 若c = a^b， 则 c^a 的结果是b、 c^b 的结果是a。

//参数：
//	a:待排序数列
//	n:数列中数的个数
void bubble_sort1(int a[], int n)
{
	for(int i = n-1; i > 0; --i)
	{
		for(int j = 0; j < i; ++j)
		{
			if(a[j] > a[j+1])
			{
				swap(a[j], a[j+1]);
			}
		}
	}
}

//参数：
//	a:待排序数列
//	n:数列中数的个数
void bubble_sort2(int a[], int n)
{
	int iflag;
	
	for(int i = n-1; i > 0; --i)
	{
		iflag = 0;
		for(int j = 0; j < i; ++j)
		{
			if(a[j] > a[j+1])
			{
				swap(a[j], a[j+1]);
				iflag = 1;
			}
		}
		
		if(iflag == 0)
		{
			break;
		}
	}
}

int main()
{
	int i = 0, n = 0;
	printf("输入数列中数的个数:");
	scanf("%d", &n);
	fflush(stdin);

	int *a = (int *)malloc(n * sizeof(int));
	int *tmp = a;	//这里的两个指针是为了用于输入和输出的，不改变指针a的指向。因为最后要释放指针，必须free a那个地址，动了a的话就不对了。
	int *tmp2 = a;	//或者可以先用指针a，然后再把指针a指回最开始地址，没试过，应该可行

	printf("依次输入数列中的数：\n");
	for(i = 0; i < n; ++i)
	{
		scanf("%d", tmp2++);
		fflush(stdin);
	}

	bubble_sort2(tmp, n);
	printf("排序后的数列:");
	for(i = 0; i < n; ++i)
	{
		printf("%d ", *(tmp++));
	}
	printf("\n");

	free(a);
	return 0;
}







